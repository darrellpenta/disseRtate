#' Data-filtering conditions as vectors
#'
#' Creates a factor grid dataframe of data-filtering conditions for passing to additional to additional factorial-design functions.
#'
#' Formula-strings for filtering a data set based on the levels of crossed factors
#'
#' @importFrom magrittr %>%
#' @include sweet_dots-function.R
#' @include factor_filter_helpers-function.R
#' @param .data a \code{factor.grid} dataframe generated by  or
#' @param ... additional arguments
#' @param .trunc_label Should the output contain a column with printing/reading-friendly, truncuated labels to indicate which factor(s)/levels(s) are being used to filter? Default is TRUE. Mutlple levels of a single factor are separated with a colon: (e.g., <code>fact1level1:fact1level2</code>); factors are separated by a double-colon: (e.g., <code>fact1level1:fact1level2::fact2level1</code>)
#' @param .for_aov A logical indicating whether the data be returned for passing to a function in @family aov-out functions? Defaults to TRUE.
#' @return a data.frame of factorial-based filtering condition or a  list for passing to additional
#' @family factorial-design functions
#' @export
#'
factor_filter <- function(.data, ...) {
  UseMethod("factor_filter", .data)
}

#' A vectorized vesion of the \code{factor_filter} function
#' @rdname factor_filter
#' @export
factor_filter.default <-
  Vectorize(
    FUN = function(.data, ...)
      factor_filter(.data, ...),
    vectorize.args = c(".data"),
    SIMPLIFY = FALSE,
    USE.NAMES = FALSE
  )

#' Derive filtering conditions from a factor grid
#'

#' @rdname factor_filter
#' @export


factor_filter.factor.grid <-
  function(.data,
           ...,
           .trunc_label = TRUE,
           .for_aov = TRUE) {
    assertthat::validate_that(
      assertthat::has_attr(.data, which = "class"),
      "factor.grid" %in% attr(.data, which = "class")
    )
    options("stringsAsFactors" = FALSE)
    ff_dots <-
      pryr::named_dots(...)
    lapply(ff_dots, eval, parent.frame())

    iv <-
      c(paste(colnames(.data)))

    dat.001 <-
      lapply(iv,
             function(iv.001,
                      dat.001.01 = .data) {
               dat.002 <-
                 dat.001.01 %>%
                 dplyr::select_(.dots = sweet_dots(iv.001))


               dat.002 <-
                 dat.002 %>%
                 dplyr::mutate(len = "",
                               form = "")

               dat.003 <-
                 tibble::tibble("col1" = dat.002[[1]])

               dat.003.01 <-
                 lapply(dat.003$col1,
                        strsplit,
                        split = ":") %>%
                 unlist(recursive = FALSE)

               len_col <- # Create "len" column
                 lapply(dat.003.01,
                        length) %>%
                 stringr::str_c()

               form_col <- # Create "form" column
                 lapply(dat.003.01,
                        ff_forms_col,
                        select_column = iv.001) %>%
                 stringr::str_c()

               dat.002 <-
                 dat.002 %>%
                 dplyr::mutate(len = len_col,
                               form = form_col)


               dat.002 <-
                 dat.002 %>%
                 `names<-`(c(
                   paste0(iv.001, "_nm"),
                   paste0(iv.001, "_len"),
                   paste0(iv.001, "_form.temp")
                 ))
               dat.002 <-
                 as.data.frame(dat.002)

             })


    dat.001 <-
      as.data.frame(dat.001) %>%
      dplyr::mutate(num_lvls = 0L,
                    label = NA_character_,
                    filter_form = NA_character_)

    dat.001["num_lvls"] <-
      ff_number_levels_col(dat.001)
    dat.001["label"] <-
      ff_label_col(dat.001)
    dat.001["filter_form"] <-
      ff_filter_f_col(dat.001)

  if (isTRUE(.for_aov) | missing(.for_aov)) {

    minimum_value <-
      min(dat.001["num_lvls"])

    dat.001 <-
      dat.001[dat.001["num_lvls"] != minimum_value,]


  } else{
    dat.001 <-
      dat.001 %>%
      dplyr::select(-dplyr::contains(match = "_len")) %>%
      dplyr::select(-dplyr::contains(match = "_nm")) %>%
      dplyr::select(-dplyr::contains(match = "_form.temp"))
    dat.001
  }


  if (isTRUE(.trunc_label) | missing(.trunc_label)) {
    everything_vector <-
      colnames(dat.001)
    everything_vector <-
      everything_vector[!everything_vector %in% c("label","num_lvls")]
    everything_vector <-
      c("label","num_lvls",everything_vector)

    dat.001 <-
      dat.001[everything_vector]

        dat.001

  } else {
    everything_vector <-
      colnames(dat.001)
    everything_vector <-
      everything_vector[!everything_vector %in% c("num_lvls")]
    everything_vector <-
      c("num_lvls",everything_vector)

    dat.001 <-
      dat.001[everything_vector]

    dat.001

    }

    dat.001 <-
      dplyr::arrange_(dat.001,
                      .dots =
                        sweet_dots(paste0("dplyr::desc(",names(dat.001)[2],")")))


  dat.001


}
