#' Data-filtering conditions as vectors
#'
#' Creates a factor grid dataframe of data-filtering conditions for passing to additional to additional factorial-design functions.
#'
#' Formula-strings for filtering a data set based on the levels of crossed factors
#'
#' @importFrom magrittr %>%
#' @include select_dots-function.R
#' @param data a \code{factor.grid} dataframe generated by  or
#' @param ... additional arguments
#' @return a data.frame of factorial-based filtering condition or a  list for passing to additional
#' @family factorial-design functions
#' @export
#'
factor_filter <- function(data, ...) {
  UseMethod("factor_filter", data)
}

#' A vectorized vesion of the \code{factor_filter} function
#' @rdname factor_filter
#' @export
factor_filter.default <-
  Vectorize(
    FUN = function(data, ...)
      factor_filter(data, ...),
    vectorize.args = c("data"),
    SIMPLIFY = FALSE,
    USE.NAMES = FALSE
  )

#' Derive filtering conditions from a factor grid
#'
#' @param trunc_label Should the output contain a column with printing/reading-friendly, truncuated labels to indicate which factor(s)/levels(s) are being used to filter? Default is TRUE. Mutlple levels of a single factor are separated with a colon: (e.g., <code>fact1level1:fact1level2</code>); factors are separated by a double-colon: (e.g., <code>fact1level1:fact1level2::fact2level1</code>)
#' @param for_aov A logical indicating whether the data be returned for passing to a function in @family aov-out functions? Defaults to TRUE.
#' @rdname factor_filter
#' @export


factor_filter.factor.grid <-
  function(data,
           ...,
           trunc_label = TRUE,
           for_aov = TRUE) {
    assertthat::validate_that(
      assertthat::has_attr(data, which = "class"),
      "factor.grid" %in% attr(data, which = "class")
    )
    options("stringsAsFactors" = FALSE)
    iv <-
      c(paste(colnames(data)))


    dat.001 <-
      lapply(iv,
             function(iv.001,
                      dat.001.01 = data) {
               dat.002 <-
                 dat.001.01 %>%
                 dplyr::select_(.dots = select_dots(iv.001))

               dat.003 <-
                 tibble::tibble("col1" = dat.002[[1]])

               dat.003.01 <-
                 lapply(dat.003$col1,
                        strsplit,
                        split = ":") %>%
                 unlist(recursive = FALSE)

               dat.002 <-
                 dat.002 %>%
                 dplyr::mutate(len = "",
                               form = "")

               len_col <-
                 lapply(dat.003.01,
                        length) %>%
                 stringr::str_c()

               form_col <-
                 lapply(dat.003.01,
                        function(dat.003.02) {
                          dat.003.02 <-
                            paste(iv.001,
                                  paste0(
                                    "c(",
                                    paste(
                                      "'",
                                      dat.003.02,
                                      "'",
                                      collapse = ",",
                                      sep = ""
                                    ),
                                    ")"
                                  ),
                                  sep = " %in% ")
                        }) %>%
                 stringr::str_c()

               dat.002 <-
                 dat.002 %>%
                 dplyr::mutate(len = len_col,
                               form = form_col)


               dat.002 <-
                 dat.002 %>%
                 `names<-`(c(
                   paste0(iv.001, "_nm"),
                   paste0(iv.001, "_len"),
                   paste0(iv.001, "_form.temp")
                 ))
             })

    dat.002 <-
      as.data.frame(dat.002)

    num_lvls <- NULL
    label <- NULL
    filter_f <- NULL

    dat.001 <-
      dat.001 %>%
      dplyr::mutate(num_lvls = num_lvls,
                    label = label,
                    filter_f = filter_f)

    num_lvls_column <-
      dat.001 %>%
      dplyr::select(dplyr::contains(match = "_len")) %>%
      dplyr::mutate_if(is.character, "as.integer") %>%
      apply(1, sum)

    lbl <- NULL

    label_column <-
      dat.001 %>%
      dplyr::select(dplyr::contains(match = "_nm")) %>%
      dplyr::mutate_all(function(x) {
        gsub(
          x = x,
          pattern = "([:]*)([a-z]{0,3})[a-z]*([:]*)",
          "\\1\\2\\3",
          ignore.case = TRUE
        )
      }) %>%
      tidyr::unite(lbl,
                   dplyr::everything(),
                   sep = "::")

    filter_fun <- NULL
    filter_f_column <-
      dat.001 %>%
      dplyr::select(dplyr::contains(match = "_form.temp")) %>%
      tidyr::unite(filter_fun,
                   dplyr::contains(match = "_form.temp"),
                   sep = " & ")


    dat.001 <-
      dat.001 %>%
      dplyr::mutate(num_lvls = num_lvls_column,
                    label = label_column[["lbl"]],
                    filter_f = filter_f_column[["filter_fun"]])


    if (isTRUE(for_aov) | missing(for_aov)) {
      #orders the data from largest analyses to smallest, removes illogical groupings
      dat.001 <-
        dat.001 %>%
        dplyr::filter(!(num_lvls %in% min(dat.001$num_lvls))) %>%
        dplyr::arrange(dplyr::desc(num_lvls))
      dat.001
    } else{
      dat.001 <-
        dat.001 %>%
        dplyr::select(-dplyr::contains(match = "_len")) %>%
        dplyr::select(-dplyr::contains(match = "_nm")) %>%
        dplyr::select(-dplyr::contains(match = "_form.temp"))
      dat.001
    }

    label <- NULL

    if (isTRUE(trunc_label) | missing(trunc_label)) {
      dat.001 <-
        dat.001 %>%
        dplyr::select(label, num_lvls, dplyr::everything())
      dat.001

    } else {
      dat.001 <-
        dat.001 %>%
        dplyr::select(num_lvls, dplyr::everything())
    }



    attr(dat.001, "class") <- c("data.frame", "filter.grid")

    dat.001


  }
